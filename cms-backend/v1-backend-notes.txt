This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-22T20:55:07.302Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
prisma/
  migrations/
    20241222172256_insurer_data/
      migration.sql
    20241222173222_update_user_roles/
      migration.sql
    20241222204653_update_user_model/
      migration.sql
    migration_lock.toml
  old.schema
  schema.prisma
  seed.js
src/
  config/
    app.ts
    supabase.ts
    swagger.ts
  controllers/
    auth.controller.ts
    claims.controller.ts
    insurers.controller.ts
  middleware/
    asyncHandler.ts
    auth.ts
    docs.ts
    errorHandler.ts
  routes/
    auth.ts
    claims.ts
    insurers.ts
  scripts/
    createSudoUser.ts
  types/
    api.ts
    auth.ts
  utils/
    apiResponse.ts
    asyncHandler.ts
    errors.ts
  index.ts
  instrument.ts
.eslintrc.json
.gitignore
backend-notes.txt
package.json
README.md
tsconfig.json

================================================================
Repository Files
================================================================

================
File: prisma/migrations/20241222172256_insurer_data/migration.sql
================
-- CreateSchema
CREATE SCHEMA IF NOT EXISTS "auth";

-- CreateEnum
CREATE TYPE "public"."LaborType" AS ENUM ('FLAT', 'MULTIPLIER');

-- CreateEnum
CREATE TYPE "public"."Role" AS ENUM ('ADMIN', 'MANAGER', 'USER');

-- CreateEnum
CREATE TYPE "public"."ClaimStatus" AS ENUM ('DRAFT', 'SUBMITTED', 'IN_REVIEW', 'APPROVED', 'REJECTED', 'COMPLETED');

-- CreateTable
CREATE TABLE "public"."User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "role" "public"."Role" NOT NULL DEFAULT 'USER',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Claim" (
    "id" TEXT NOT NULL,
    "claimNumber" TEXT NOT NULL,
    "status" "public"."ClaimStatus" NOT NULL DEFAULT 'DRAFT',
    "assignedToId" TEXT,
    "totalAmount" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Claim_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."VehicleInfo" (
    "id" TEXT NOT NULL,
    "make" TEXT NOT NULL,
    "model" TEXT NOT NULL,
    "year" INTEGER NOT NULL,
    "vin" TEXT NOT NULL,
    "claimId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "VehicleInfo_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Part" (
    "id" TEXT NOT NULL,
    "partNumber" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "quantity" INTEGER NOT NULL,
    "unitPrice" DOUBLE PRECISION NOT NULL,
    "claimId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Part_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Document" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "url" TEXT NOT NULL,
    "claimId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Document_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."Insurer" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "address" TEXT NOT NULL,
    "phone" TEXT NOT NULL,
    "billingEmail" TEXT NOT NULL,
    "carrierNote" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Insurer_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."PricingRules" (
    "id" TEXT NOT NULL,
    "domesticWindshield" DOUBLE PRECISION NOT NULL,
    "domesticTempered" DOUBLE PRECISION NOT NULL,
    "foreignWindshield" DOUBLE PRECISION NOT NULL,
    "foreignTempered" DOUBLE PRECISION NOT NULL,
    "oem" DOUBLE PRECISION NOT NULL,
    "laborType" "public"."LaborType" NOT NULL,
    "laborTypeValue" DOUBLE PRECISION NOT NULL,
    "glassLaborRate" DOUBLE PRECISION NOT NULL,
    "defaultHourlyRate" DOUBLE PRECISION NOT NULL,
    "laborDomesticWindshield" DOUBLE PRECISION NOT NULL,
    "laborDomesticTempered" DOUBLE PRECISION NOT NULL,
    "laborForeignWindshield" DOUBLE PRECISION NOT NULL,
    "laborForeignTempered" DOUBLE PRECISION NOT NULL,
    "otherKitFlat" DOUBLE PRECISION NOT NULL,
    "kitFlat1" DOUBLE PRECISION NOT NULL,
    "kitFlat1_5" DOUBLE PRECISION NOT NULL,
    "kitFlat2" DOUBLE PRECISION NOT NULL,
    "kitFlat2_5" DOUBLE PRECISION NOT NULL,
    "kitFlat3" DOUBLE PRECISION NOT NULL,
    "insurerId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "PricingRules_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "public"."User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Claim_claimNumber_key" ON "public"."Claim"("claimNumber");

-- CreateIndex
CREATE UNIQUE INDEX "VehicleInfo_claimId_key" ON "public"."VehicleInfo"("claimId");

-- CreateIndex
CREATE UNIQUE INDEX "PricingRules_insurerId_key" ON "public"."PricingRules"("insurerId");

-- AddForeignKey
ALTER TABLE "public"."Claim" ADD CONSTRAINT "Claim_assignedToId_fkey" FOREIGN KEY ("assignedToId") REFERENCES "public"."User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."VehicleInfo" ADD CONSTRAINT "VehicleInfo_claimId_fkey" FOREIGN KEY ("claimId") REFERENCES "public"."Claim"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."Part" ADD CONSTRAINT "Part_claimId_fkey" FOREIGN KEY ("claimId") REFERENCES "public"."Claim"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."Document" ADD CONSTRAINT "Document_claimId_fkey" FOREIGN KEY ("claimId") REFERENCES "public"."Claim"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."PricingRules" ADD CONSTRAINT "PricingRules_insurerId_fkey" FOREIGN KEY ("insurerId") REFERENCES "public"."Insurer"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: prisma/migrations/20241222173222_update_user_roles/migration.sql
================
/*
  Warnings:

  - The values [MANAGER] on the enum `Role` will be removed. If these variants are still used in the database, this will fail.

*/
-- AlterEnum
BEGIN;
CREATE TYPE "public"."Role_new" AS ENUM ('USER', 'CCA', 'CCM', 'ADMIN', 'SUDO');
ALTER TABLE "public"."User" ALTER COLUMN "role" DROP DEFAULT;
ALTER TABLE "public"."User" ALTER COLUMN "role" TYPE "public"."Role_new" USING ("role"::text::"public"."Role_new");
ALTER TYPE "public"."Role" RENAME TO "Role_old";
ALTER TYPE "public"."Role_new" RENAME TO "Role";
DROP TYPE "public"."Role_old";
ALTER TABLE "public"."User" ALTER COLUMN "role" SET DEFAULT 'USER';
COMMIT;

================
File: prisma/migrations/20241222204653_update_user_model/migration.sql
================
/*
  Warnings:

  - You are about to drop the `User` table. If the table is not empty, all the data it contains will be lost.

*/
-- DropForeignKey
ALTER TABLE "public"."Claim" DROP CONSTRAINT "Claim_assignedToId_fkey";

-- DropTable
DROP TABLE "public"."User";

-- CreateTable
CREATE TABLE "public"."users" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "first_name" TEXT,
    "last_name" TEXT,
    "phone" TEXT,
    "role" "public"."Role" NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "public"."users"("email");

-- AddForeignKey
ALTER TABLE "public"."Claim" ADD CONSTRAINT "Claim_assignedToId_fkey" FOREIGN KEY ("assignedToId") REFERENCES "public"."users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

================
File: prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

================
File: prisma/old.schema
================
// This is your Prisma schema file
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "@prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  claims    Claim[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Claim {
  id            String         @id @default(uuid())
  claimNumber   String        @unique
  status        ClaimStatus   @default(DRAFT)
  vehicleInfo   VehicleInfo?
  parts         Part[]
  documents     Document[]
  assignedTo    User?         @relation(fields: [assignedToId], references: [id])
  assignedToId  String?
  totalAmount   Float         @default(0)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
}

model VehicleInfo {
  id          String   @id @default(uuid())
  make        String
  model       String
  year        Int
  vin         String
  claim       Claim    @relation(fields: [claimId], references: [id])
  claimId     String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Part {
  id          String    @id @default(uuid())
  partNumber  String
  description String
  quantity    Int
  unitPrice   Float
  claim       Claim     @relation(fields: [claimId], references: [id])
  claimId     String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model Document {
  id          String    @id @default(uuid())
  name        String
  type        String
  url         String
  claim       Claim     @relation(fields: [claimId], references: [id])
  claimId     String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

enum Role {
  ADMIN
  MANAGER
  USER
}

enum ClaimStatus {
  DRAFT
  SUBMITTED
  IN_REVIEW
  APPROVED
  REJECTED
  COMPLETED
}

================
File: prisma/schema.prisma
================
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema"]
}

datasource db {
  provider = "postgresql"
  url      = env("DIRECT_URL")
  schemas  = ["auth", "public"]
}

model User {
  id         String   @id @default(uuid())
  email      String   @unique
  first_name String?
  last_name  String?
  phone      String?
  role       Role
  created_at DateTime @default(now())
  updated_at DateTime @default(now()) @updatedAt
  claims     Claim[]

  @@schema("public")
  @@map("users")
}

model Claim {
  id           String       @id @default(uuid())
  claimNumber  String       @unique
  status       ClaimStatus  @default(DRAFT)
  assignedToId String?
  totalAmount  Float        @default(0)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  assignedTo   User?        @relation(fields: [assignedToId], references: [id])
  documents    Document[]
  parts        Part[]
  vehicleInfo  VehicleInfo?

  @@schema("public")
}

model VehicleInfo {
  id        String   @id @default(uuid())
  make      String
  model     String
  year      Int
  vin       String
  claimId   String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  claim     Claim    @relation(fields: [claimId], references: [id])

  @@schema("public")
}

model Part {
  id          String   @id @default(uuid())
  partNumber  String
  description String
  quantity    Int
  unitPrice   Float
  claimId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  claim       Claim    @relation(fields: [claimId], references: [id])

  @@schema("public")
}

model Document {
  id        String   @id @default(uuid())
  name      String
  type      String
  url       String
  claimId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  claim     Claim    @relation(fields: [claimId], references: [id])

  @@schema("public")
}

model Insurer {
  id           String        @id @default(uuid())
  name         String
  address      String
  phone        String
  billingEmail String
  carrierNote  String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  pricingRules PricingRules?

  @@schema("public")
}

model PricingRules {
  id                      String    @id @default(uuid())
  domesticWindshield      Float
  domesticTempered        Float
  foreignWindshield       Float
  foreignTempered         Float
  oem                     Float
  laborType               LaborType
  laborTypeValue          Float
  glassLaborRate          Float
  defaultHourlyRate       Float
  laborDomesticWindshield Float
  laborDomesticTempered   Float
  laborForeignWindshield  Float
  laborForeignTempered    Float
  otherKitFlat            Float
  kitFlat1                Float
  kitFlat1_5              Float
  kitFlat2                Float
  kitFlat2_5              Float
  kitFlat3                Float
  insurerId               String    @unique
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  insurer                 Insurer   @relation(fields: [insurerId], references: [id])

  @@schema("public")
}

enum LaborType {
  FLAT
  MULTIPLIER

  @@schema("public")
}

enum Role {
  USER
  CCA
  CCM
  ADMIN
  SUDO

  @@schema("public")
}

enum ClaimStatus {
  DRAFT
  SUBMITTED
  IN_REVIEW
  APPROVED
  REJECTED
  COMPLETED

  @@schema("public")
}

================
File: prisma/seed.js
================
const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();

async function main() {
  const email = "sudo@example.com";

  try {
    const user = await prisma.user.upsert({
      where: { email: email },
      update: {},
      create: {
        email: email,
        first_name: "Super",
        last_name: "Admin",
        role: "SUDO",
        phone: null, // Add phone number if available
      },
    });

    console.log("User created or updated:", user);

    // Note: Supabase trigger should automatically create the corresponding Auth user
    console.log(
      "A Supabase trigger should create the corresponding Auth user automatically."
    );
    console.log(
      "Please check your Supabase dashboard to confirm the Auth user was created."
    );
  } catch (error) {
    console.error("Error creating/updating user:", error);
  }
}

main()
  .catch((e) => console.error(e))
  .finally(async () => {
    await prisma.$disconnect();
  });

================
File: src/config/app.ts
================
// src/config/app.ts
import dotenv from "dotenv";

dotenv.config();

export const config = {
  app: {
    name: "CMS Backend",
    port: process.env.PORT || 5001,
    env: process.env.NODE_ENV || "development",
  },
  supabase: {
    url: process.env.SUPABASE_URL,
    anonKey: process.env.SUPABASE_ANON_KEY,
    serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY,
  },
  sentry: {
    dsn: process.env.SENTRY_DSN,
  },
  database: {
    url: process.env.DATABASE_URL,
    directUrl: process.env.DIRECT_URL,
  },
};

================
File: src/config/supabase.ts
================
// src/config/supabase.ts
import { createClient } from "@supabase/supabase-js";
import { config } from "./app";

if (!config.supabase.url || !config.supabase.anonKey) {
  throw new Error("Missing Supabase configuration");
}

export const supabase = createClient(
  config.supabase.url,
  config.supabase.anonKey
);

// Define the enum first
export enum UserRole {
  USER = "USER", // Web user
  CCA = "CCA", // Call Centre Agent
  CCM = "CCM", // Call Centre Manager
  ADMIN = "ADMIN", // Administrator
  SUDO = "SUDO", // Super Admin
}

// Then use it in ROLE_HIERARCHY
export const ROLE_HIERARCHY: Record<UserRole, number> = {
  [UserRole.SUDO]: 5,
  [UserRole.ADMIN]: 4,
  [UserRole.CCM]: 3,
  [UserRole.CCA]: 2,
  [UserRole.USER]: 1,
};

// Add a type guard function to check if a string is a valid UserRole
export function isValidUserRole(role: string): role is UserRole {
  return Object.values(UserRole).includes(role as UserRole);
}

================
File: src/config/swagger.ts
================
// src/config/swagger.ts
import swaggerJsdoc from "swagger-jsdoc";

const options = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "CMS Backend API Documentation",
      version: "1.0.0",
      description: "Documentation for the Claims Management System API",
      license: {
        name: "MIT",
        url: "https://spdx.org/licenses/MIT.html",
      },
      contact: {
        name: "API Support",
        url: "https://your-support-url.com",
        email: "your-email@example.com",
      },
    },
    servers: [
      {
        url: "http://localhost:5001",
        description: "Development server",
      },
      {
        url: "https://your-production-url.com",
        description: "Production server",
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          bearerFormat: "JWT",
        },
      },
    },
  },
  apis: ["./src/routes/*.ts"], // Path to the API routes
};

export const specs = swaggerJsdoc(options);

================
File: src/controllers/auth.controller.ts
================
// src/controllers/auth.controller.ts
import { Request, Response } from "express";
import { supabase } from "../config/supabase";
import { ApiResponse } from "../utils/apiResponse";
import { AppError } from "../utils/errors";
import { AuthenticatedRequest } from "../middleware/auth";
import {
  LoginRequest,
  RegisterRequest,
  UpdateProfileRequest,
} from "../types/auth";

export class AuthController {
  static async register(req: Request, res: Response) {
    try {
      const {
        email,
        password,
        firstName,
        lastName,
        phone,
        role,
      }: RegisterRequest = req.body;

      // Register user with Supabase Auth
      const { data: authData, error: authError } = await supabase.auth.signUp({
        email,
        password,
      });

      if (authError) throw new AppError(authError.message, 400);

      // Create user profile
      const { data: profileData, error: profileError } = await supabase
        .from("users") // Changed from user_profiles to users
        .insert({
          id: authData.user!.id,
          email,
          first_name: firstName,
          last_name: lastName,
          phone,
          role: role || "USER",
          created_at: new Date(),
          updated_at: new Date(),
        })
        .single();

      if (profileError) throw new AppError(profileError.message, 400);

      return ApiResponse.success(
        res,
        profileData,
        "User registered successfully",
        201
      );
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  }

  static async login(req: Request, res: Response) {
    try {
      const { email, password }: LoginRequest = req.body;

      // Authenticate with Supabase
      const { data: authData, error: authError } =
        await supabase.auth.signInWithPassword({
          email,
          password,
        });

      if (authError) throw new AppError(authError.message, 401);

      // Fetch user profile including role
      const { data: userData, error: userError } = await supabase
        .from("users")
        .select("*")
        .eq("id", authData.user.id)
        .single();

      if (userError) throw new AppError(userError.message, 400);

      // Update last sign in
      await supabase
        .from("users")
        .update({ updated_at: new Date() })
        .eq("id", authData.user.id);

      // Combine auth data with user profile
      const responseData = {
        user: {
          ...authData.user,
          ...userData, // This will include the role
        },
        session: authData.session,
      };

      return ApiResponse.success(res, responseData, "Login successful");
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  }

  static async logout(req: AuthenticatedRequest, res: Response) {
    try {
      const { error } = await supabase.auth.signOut();

      if (error) throw new AppError(error.message, 400);

      return ApiResponse.success(res, null, "Logout successful");
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  }

  static async getProfile(req: AuthenticatedRequest, res: Response) {
    try {
      const { data: profile, error } = await supabase
        .from("users")
        .select("*")
        .eq("id", req.user.id)
        .single();

      if (error) throw new AppError(error.message, 400);

      return ApiResponse.success(
        res,
        profile,
        "Profile retrieved successfully"
      );
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  }

  static async updateProfile(req: AuthenticatedRequest, res: Response) {
    try {
      const { firstName, lastName, phone }: UpdateProfileRequest = req.body;

      const { data, error } = await supabase
        .from("users") // Changed from user_profiles to users
        .update({
          first_name: firstName,
          last_name: lastName,
          phone,
          updated_at: new Date(),
        })
        .eq("id", req.user.id)
        .single();

      if (error) throw new AppError(error.message, 400);

      return ApiResponse.success(res, data, "Profile updated successfully");
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  }
}

================
File: src/controllers/claims.controller.ts
================
import { Request, Response } from "express";
import { PrismaClient } from "@prisma/client";
import { asyncHandler } from "../middleware/asyncHandler";

const prisma = new PrismaClient();

// Get all claims with pagination
export const getClaims = asyncHandler(async (req: Request, res: Response) => {
  const page = parseInt(req.query.page as string) || 1;
  const limit = parseInt(req.query.limit as string) || 10;
  const skip = (page - 1) * limit;

  const [claims, total] = await Promise.all([
    prisma.claim.findMany({
      skip,
      take: limit,
      include: {
        vehicleInfo: true,
        assignedTo: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    }),
    prisma.claim.count(),
  ]);

  res.json({
    success: true,
    data: claims,
    pagination: {
      total,
      page,
      pages: Math.ceil(total / limit),
      limit,
    },
  });
});

// Get single claim
export const getClaim = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;

  const claim = await prisma.claim.findUnique({
    where: { id },
    include: {
      vehicleInfo: true,
      parts: true,
      documents: true,
      assignedTo: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  if (!claim) {
    return res.status(404).json({
      success: false,
      error: "Claim not found",
    });
  }

  res.json({
    success: true,
    data: claim,
  });
});

// Create new claim
export const createClaim = asyncHandler(async (req: Request, res: Response) => {
  const { vehicleInfo, ...claimData } = req.body;

  const claim = await prisma.claim.create({
    data: {
      ...claimData,
      vehicleInfo: {
        create: vehicleInfo,
      },
    },
    include: {
      vehicleInfo: true,
    },
  });

  res.status(201).json({
    success: true,
    data: claim,
  });
});

// Update claim
export const updateClaim = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;
  const { vehicleInfo, ...claimData } = req.body;

  const claim = await prisma.claim.update({
    where: { id },
    data: {
      ...claimData,
      vehicleInfo: vehicleInfo
        ? {
            update: vehicleInfo,
          }
        : undefined,
    },
    include: {
      vehicleInfo: true,
      parts: true,
      documents: true,
    },
  });

  res.json({
    success: true,
    data: claim,
  });
});

// Delete claim
export const deleteClaim = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;

  await prisma.claim.delete({
    where: { id },
  });

  res.json({
    success: true,
    data: {},
  });
});

// Add part to claim
export const addPartToClaim = asyncHandler(
  async (req: Request, res: Response) => {
    const { id } = req.params;
    const partData = req.body;

    const part = await prisma.part.create({
      data: {
        ...partData,
        claim: {
          connect: { id },
        },
      },
    });

    // Update claim total amount
    await prisma.claim.update({
      where: { id },
      data: {
        totalAmount: {
          increment: partData.quantity * partData.unitPrice,
        },
      },
    });

    res.status(201).json({
      success: true,
      data: part,
    });
  }
);

// Upload document
export const uploadDocument = asyncHandler(
  async (req: Request, res: Response) => {
    const { id } = req.params;
    const { name, type, url } = req.body;

    const document = await prisma.document.create({
      data: {
        name,
        type,
        url,
        claim: {
          connect: { id },
        },
      },
    });

    res.status(201).json({
      success: true,
      data: document,
    });
  }
);

================
File: src/controllers/insurers.controller.ts
================
import { Request, Response, NextFunction } from "express";
import { PrismaClient } from "@prisma/client";
import { AppError } from "../utils/errors";
import { ApiResponse } from "../utils/apiResponse";
import { asyncHandler } from "../utils/asyncHandler";

const prisma = new PrismaClient();

export const createInsurer = asyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const { name, address, phone, billingEmail, carrierNote, pricingRules } =
      req.body;

    const insurer = await prisma.insurer.create({
      data: {
        name,
        address,
        phone,
        billingEmail,
        carrierNote,
        pricingRules: {
          create: pricingRules,
        },
      },
      include: {
        pricingRules: true,
      },
    });

    ApiResponse.success(res, insurer, "Insurer created successfully", 201);
  }
);

export const getInsurers = asyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const insurers = await prisma.insurer.findMany({
      include: {
        pricingRules: true,
      },
    });

    ApiResponse.success(res, insurers, "Insurers retrieved successfully");
  }
);

export const getInsurer = asyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const { id } = req.params;

    const insurer = await prisma.insurer.findUnique({
      where: { id },
      include: {
        pricingRules: true,
      },
    });

    if (!insurer) {
      throw new AppError("Insurer not found", 404);
    }

    ApiResponse.success(res, insurer, "Insurer retrieved successfully");
  }
);

export const updateInsurer = asyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const { id } = req.params;
    const { name, address, phone, billingEmail, carrierNote, pricingRules } =
      req.body;

    const insurer = await prisma.insurer.update({
      where: { id },
      data: {
        name,
        address,
        phone,
        billingEmail,
        carrierNote,
        pricingRules: {
          update: pricingRules,
        },
      },
      include: {
        pricingRules: true,
      },
    });

    ApiResponse.success(res, insurer, "Insurer updated successfully");
  }
);

export const deleteInsurer = asyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const { id } = req.params;

    await prisma.insurer.delete({
      where: { id },
    });

    ApiResponse.success(res, null, "Insurer deleted successfully");
  }
);

================
File: src/middleware/asyncHandler.ts
================
import { Request, Response, NextFunction, RequestHandler } from "express";

type AsyncRequestHandler = (
  req: Request,
  res: Response,
  next: NextFunction
) => Promise<any>;

export const asyncHandler =
  (fn: AsyncRequestHandler): RequestHandler =>
  (req: Request, res: Response, next: NextFunction): void => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };

================
File: src/middleware/auth.ts
================
// src/middleware/auth.ts
import { Request, Response, NextFunction } from "express";
import { supabase, UserRole, ROLE_HIERARCHY } from "../config/supabase";
import { AppError } from "../utils/errors";
import { ApiResponse } from "../utils/apiResponse";

export interface AuthenticatedRequest extends Request {
  user?: any;
}

export const authenticate = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];

    if (!token) {
      throw new AppError("No authentication token provided", 401);
    }

    const {
      data: { user },
      error,
    } = await supabase.auth.getUser(token);

    if (error || !user) {
      throw new AppError("Invalid or expired token", 401);
    }

    // Get user's role from user_profiles table
    const { data: profile, error: profileError } = await supabase
      .from("user_profiles")
      .select("*")
      .eq("id", user.id)
      .single();

    if (profileError || !profile) {
      throw new AppError("User profile not found", 404);
    }

    req.user = { ...user, ...profile };
    next();
  } catch (error) {
    return ApiResponse.error(res, error.message, error.statusCode || 500);
  }
};

export const authorize = (...allowedRoles: UserRole[]) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      if (!req.user || !req.user.role) {
        throw new AppError("User not authenticated", 401);
      }

      const userRoleLevel = ROLE_HIERARCHY[req.user.role];
      const hasPermission = allowedRoles.some(
        (role) => ROLE_HIERARCHY[role] <= userRoleLevel
      );

      if (!hasPermission) {
        throw new AppError("Insufficient permissions", 403);
      }

      next();
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  };
};

================
File: src/middleware/docs.ts
================
// src/middleware/docs.ts
import { Express, Request, Response } from "express";
import swaggerUi from "swagger-ui-express";
import { specs } from "../config/swagger";

export const setupDocs = (app: Express) => {
  // Swagger documentation route
  app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(specs));

  // JSON version of documentation
  app.get("/api-docs.json", (req: Request, res: Response) => {
    res.setHeader("Content-Type", "application/json");
    res.send(specs);
  });
};

================
File: src/middleware/errorHandler.ts
================
// src/middleware/errorHandler.ts
import { Request, Response, NextFunction } from "express";
import * as Sentry from "@sentry/node";
import { config } from "../config/app";
import { AppError } from "../utils/errors";

export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Log error
  console.error(error);

  // Capture error in Sentry
  Sentry.captureException(error);

  // Check if error is operational
  if (error instanceof AppError) {
    return res.status(error.statusCode).json({
      status: error.status,
      message: error.message,
      ...(config.app.env === "development" && { stack: error.stack }),
    });
  }

  // Handle unexpected errors
  return res.status(500).json({
    status: "error",
    message: "Something went wrong!",
    ...(config.app.env === "development" && { stack: error.stack }),
    ...(res.sentry ? { sentryEventId: res.sentry } : {}),
  });
};

================
File: src/routes/auth.ts
================
// src/routes/auth.ts
import { Router } from "express";
import { AuthController } from "../controllers/auth.controller";
import { authenticate, authorize } from "../middleware/auth";
import { UserRole } from "../config/supabase";
import { asyncHandler } from "../middleware/asyncHandler";

const router = Router();

/**
 * @swagger
 * /auth/register:
 *   post:
 *     summary: Register a new user
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - firstName
 *               - lastName
 *             properties:
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               phone:
 *                 type: string
 *               role:
 *                 type: string
 *                 enum: [USER, CCA, CCM, ADMIN, SUDO]
 */
router.post(
  "/register",
  authenticate,
  authorize(UserRole.ADMIN, UserRole.SUDO),
  asyncHandler(AuthController.register)
);

/**
 * @swagger
 * /auth/login:
 *   post:
 *     summary: Login to the application
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 */
router.post("/login", asyncHandler(AuthController.login));

/**
 * @swagger
 * /auth/logout:
 *   post:
 *     summary: Logout from the application
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 */
router.post("/logout", authenticate, asyncHandler(AuthController.logout));

/**
 * @swagger
 * /auth/profile:
 *   get:
 *     summary: Get user profile
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 */
router.get("/profile", authenticate, asyncHandler(AuthController.getProfile));

/**
 * @swagger
 * /auth/profile:
 *   put:
 *     summary: Update user profile
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               phone:
 *                 type: string
 */
router.put(
  "/profile",
  authenticate,
  asyncHandler(AuthController.updateProfile)
);

export default router;

================
File: src/routes/claims.ts
================
import express from "express";
import {
  getClaims,
  getClaim,
  createClaim,
  updateClaim,
  deleteClaim,
  addPartToClaim,
  uploadDocument,
} from "../controllers/claims.controller";
import { authenticate } from "../middleware/auth";
import { asyncHandler } from "../middleware/asyncHandler";

const router = express.Router();

/**
 * @swagger
 * /api/claims:
 *   get:
 *     summary: Get all claims with pagination
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *         description: Page number
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of claims
 */
router.get("/", authenticate, asyncHandler(getClaims));

/**
 * @swagger
 * /api/claims/{id}:
 *   get:
 *     summary: Get a single claim by ID
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Claim details
 *       404:
 *         description: Claim not found
 */
router.get("/:id", authenticate, asyncHandler(getClaim));

/**
 * @swagger
 * /api/claims:
 *   post:
 *     summary: Create a new claim
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - claimNumber
 *               - vehicleInfo
 *             properties:
 *               claimNumber:
 *                 type: string
 *               vehicleInfo:
 *                 type: object
 *     responses:
 *       201:
 *         description: Claim created successfully
 */
router.post("/", authenticate, asyncHandler(createClaim));

/**
 * @swagger
 * /api/claims/{id}:
 *   put:
 *     summary: Update a claim
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *     responses:
 *       200:
 *         description: Claim updated successfully
 *       404:
 *         description: Claim not found
 */
router.put("/:id", authenticate, asyncHandler(updateClaim));

/**
 * @swagger
 * /api/claims/{id}:
 *   delete:
 *     summary: Delete a claim
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Claim deleted successfully
 *       404:
 *         description: Claim not found
 */
router.delete("/:id", authenticate, asyncHandler(deleteClaim));

/**
 * @swagger
 * /api/claims/{id}/parts:
 *   post:
 *     summary: Add a part to a claim
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - partNumber
 *               - description
 *               - quantity
 *               - unitPrice
 *             properties:
 *               partNumber:
 *                 type: string
 *               description:
 *                 type: string
 *               quantity:
 *                 type: number
 *               unitPrice:
 *                 type: number
 *     responses:
 *       201:
 *         description: Part added successfully
 */
router.post("/:id/parts", authenticate, asyncHandler(addPartToClaim));

/**
 * @swagger
 * /api/claims/{id}/documents:
 *   post:
 *     summary: Upload a document to a claim
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - type
 *               - url
 *             properties:
 *               name:
 *                 type: string
 *               type:
 *                 type: string
 *               url:
 *                 type: string
 *     responses:
 *       201:
 *         description: Document uploaded successfully
 */
router.post("/:id/documents", authenticate, asyncHandler(uploadDocument));

export default router;

================
File: src/routes/insurers.ts
================
import express from "express";
import { authenticate, authorize } from "../middleware/auth";
import { UserRole } from "../config/supabase";
import {
  createInsurer,
  getInsurers,
  getInsurer,
  updateInsurer,
  deleteInsurer,
} from "../controllers/insurers.controller";

const router = express.Router();

// Only CCM, ADMIN, and SUDO roles can access these routes
const authorizedRoles = [UserRole.CCM, UserRole.ADMIN, UserRole.SUDO];

router.post("/", authenticate, authorize(...authorizedRoles), createInsurer);
router.get("/", authenticate, authorize(...authorizedRoles), getInsurers);
router.get("/:id", authenticate, authorize(...authorizedRoles), getInsurer);
router.put("/:id", authenticate, authorize(...authorizedRoles), updateInsurer);
router.delete(
  "/:id",
  authenticate,
  authorize(...authorizedRoles),
  deleteInsurer
);

export default router;

================
File: src/scripts/createSudoUser.ts
================
import { createClient } from "@supabase/supabase-js";
import dotenv from "dotenv";

dotenv.config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceRoleKey) {
  console.error("Missing Supabase URL or service role key");
  process.exit(1);
}

// Initialize Supabase client with service_role key
const supabase = createClient(supabaseUrl, supabaseServiceRoleKey);

const setupDatabase = async () => {
  // Clean up existing data and structure
  const cleanupQueries = [
    'DROP POLICY IF EXISTS "Super admins have full access" ON public.users;',
    'DROP POLICY IF EXISTS "Users can view own record" ON public.users;',
    'DROP POLICY IF EXISTS "Enable read access for all users" ON public.users;',
    "DROP FUNCTION IF EXISTS handle_updated_at CASCADE;",
    "DROP TABLE IF EXISTS public.users CASCADE;",
    "DELETE FROM auth.users;",
  ];

  for (const query of cleanupQueries) {
    const { error } = await supabase.rpc("exec", { query });
    if (error) console.error("Error in cleanup:", error);
  }

  // Create fresh structure
  const setupQueries = [
    `CREATE TABLE public.users (
      id UUID REFERENCES auth.users(id) PRIMARY KEY,
      email TEXT UNIQUE NOT NULL,
      first_name TEXT,
      last_name TEXT,
      phone TEXT,
      role TEXT NOT NULL CHECK (role IN ('USER', 'CCA', 'CCM', 'ADMIN', 'SUDO')),
      created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
      updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
    );`,
    "ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;",
    `CREATE POLICY "Users can view own record" ON public.users
      FOR SELECT
      USING (auth.uid() = id);`,
    "GRANT ALL ON public.users TO authenticated;",
    "GRANT ALL ON public.users TO service_role;",
    "CREATE INDEX idx_users_email ON public.users(email);",
    "CREATE INDEX idx_users_role ON public.users(role);",
  ];

  for (const query of setupQueries) {
    const { error } = await supabase.rpc("exec", { query });
    if (error) console.error("Error in setup:", error);
  }
};

const createSudoUser = async () => {
  const email = "newtrojan@gmail.com";
  const password = "Test123!";

  // Create user in Supabase Auth
  const { data: authData, error: authError } =
    await supabase.auth.admin.createUser({
      email,
      password,
      email_confirm: true,
      user_metadata: { role: "SUDO" },
    });

  if (authError) {
    console.error("Error creating sudo user in Auth:", authError);
    return;
  }

  console.log("Sudo user created in Auth:", authData);

  // Insert user into public.users table
  const { data: userData, error: userError } = await supabase
    .from("users")
    .insert([
      {
        id: authData.user.id,
        email: email,
        first_name: "Super",
        last_name: "Admin",
        role: "SUDO",
      },
    ]);

  if (userError) {
    console.error("Error inserting user into public.users table:", userError);
  } else {
    console.log("User inserted into public.users table:", userData);
  }

  console.log("Sudo user created with email:", email);
  console.log("Password:", password);
  console.log("Please change the password after first login.");
};

const main = async () => {
  await setupDatabase();
  await createSudoUser();
};

main().catch(console.error);

================
File: src/types/api.ts
================
// src/types/api.ts
export interface ErrorResponse {
  error: string;
  details?: any;
}

export interface SuccessResponse<T> {
  data: T;
  message?: string;
}

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
}

================
File: src/types/auth.ts
================
// src/types/auth.ts

export enum UserRole {
  USER = "USER", // Web user
  CCA = "CCA", // Call Centre Agent
  CCM = "CCM", // Call Centre Manager
  ADMIN = "ADMIN", // Administrator
  SUDO = "SUDO", // Super Admin
}

export const ROLE_HIERARCHY = {
  [UserRole.SUDO]: 5,
  [UserRole.ADMIN]: 4,
  [UserRole.CCM]: 3,
  [UserRole.CCA]: 2,
  [UserRole.USER]: 1,
};

// Role permissions interface
export interface RolePermissions {
  canViewDashboard: boolean;
  canHandleCalls: boolean;
  canManageAgents: boolean;
  canViewReports: boolean;
  canManageUsers: boolean;
  canManageSystem: boolean;
}

// Default permissions for each role
export const ROLE_PERMISSIONS: Record<UserRole, RolePermissions> = {
  [UserRole.SUDO]: {
    canViewDashboard: true,
    canHandleCalls: true,
    canManageAgents: true,
    canViewReports: true,
    canManageUsers: true,
    canManageSystem: true,
  },
  [UserRole.ADMIN]: {
    canViewDashboard: true,
    canHandleCalls: true,
    canManageAgents: true,
    canViewReports: true,
    canManageUsers: true,
    canManageSystem: false,
  },
  [UserRole.CCM]: {
    canViewDashboard: true,
    canHandleCalls: true,
    canManageAgents: true,
    canViewReports: true,
    canManageUsers: false,
    canManageSystem: false,
  },
  [UserRole.CCA]: {
    canViewDashboard: true,
    canHandleCalls: true,
    canManageAgents: false,
    canViewReports: false,
    canManageUsers: false,
    canManageSystem: false,
  },
  [UserRole.USER]: {
    canViewDashboard: false,
    canHandleCalls: false,
    canManageAgents: false,
    canViewReports: false,
    canManageUsers: false,
    canManageSystem: false,
  },
};

// User interface
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: UserRole;
  phone?: string;
  createdAt?: Date;
  updatedAt?: Date;
}

// Helper functions
export function hasPermission(
  role: UserRole,
  permission: keyof RolePermissions
): boolean {
  return ROLE_PERMISSIONS[role][permission];
}

export function isRoleHigherThan(role1: UserRole, role2: UserRole): boolean {
  return ROLE_HIERARCHY[role1] > ROLE_HIERARCHY[role2];
}

// Auth response types
export interface AuthResponse {
  user: User | null;
  session: any | null;
  error?: string;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterData extends LoginCredentials {
  firstName: string;
  lastName: string;
  phone?: string;
  role?: UserRole;
}

================
File: src/utils/apiResponse.ts
================
// src/utils/apiResponse.ts
import { Response } from "express";
import {
  SuccessResponse,
  ErrorResponse,
  PaginatedResponse,
} from "../types/api";

export class ApiResponse {
  static success<T>(
    res: Response,
    data: T,
    message?: string,
    statusCode = 200
  ): Response {
    const response: SuccessResponse<T> = {
      data,
      message,
    };
    return res.status(statusCode).json(response);
  }

  static error(
    res: Response,
    error: string,
    statusCode = 500,
    details?: any
  ): Response {
    const response: ErrorResponse = {
      error,
      details,
    };
    return res.status(statusCode).json(response);
  }

  static paginated<T>(
    res: Response,
    data: T[],
    total: number,
    page: number,
    limit: number
  ): Response {
    const response: PaginatedResponse<T> = {
      data,
      total,
      page,
      limit,
    };
    return res.status(200).json(response);
  }
}

================
File: src/utils/asyncHandler.ts
================
import { Request, Response, NextFunction, RequestHandler } from "express";

type AsyncRequestHandler = (
  req: Request,
  res: Response,
  next: NextFunction
) => Promise<void | Response>;

export const asyncHandler = (fn: AsyncRequestHandler): RequestHandler => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

================
File: src/utils/errors.ts
================
// src/utils/errors.ts
export class AppError extends Error {
  statusCode: number;
  status: string;
  isOperational: boolean;

  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith("4") ? "fail" : "error";
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

================
File: src/index.ts
================
// src/index.ts
import "./instrument"; // Must be first import
import * as Sentry from "@sentry/node";
import express from "express";
import cors from "cors";
import helmet from "helmet";
import { config } from "./config/app";
import { setupDocs } from "./middleware/docs";
import authRoutes from "./routes/auth";
import insurerRoutes from "./routes/insurers";

const app = express();

// Basic middleware
app.use(cors());
app.use(helmet());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Setup API documentation
setupDocs(app);

// Routes
app.use("/auth", authRoutes);
app.use("/insurers", insurerRoutes);

// Basic health check route
app.get("/health", (_req, res) => {
  res.json({
    status: "ok",
    timestamp: new Date(),
    environment: config.app.env,
  });
});

// Test Sentry
app.get("/debug-sentry", (_req, _res) => {
  throw new Error("My first Sentry error!");
});

// The error handler must be registered before any other error middleware and after all controllers
Sentry.setupExpressErrorHandler(app);

// Optional fallthrough error handler
app.use(function onError(
  err: Error,
  _req: express.Request,
  res: express.Response,
  _next: express.NextFunction
) {
  // The error id is attached to `res.locals.sentry` to be returned
  res.statusCode = 500;
  res.end((res.locals as any).sentry + "\n");
});

// Start server
const server = app.listen(config.app.port, () => {
  console.log(
    ` Server running on port ${config.app.port} in ${config.app.env} mode`
  );
});

export default server;

================
File: src/instrument.ts
================
import { dotenv } from "dotenv";
// src/instrument.ts
import * as Sentry from "@sentry/node";
import { nodeProfilingIntegration } from "@sentry/profiling-node";

Sentry.init({
  dsn: process.env.SENTRY_DSN, // Replace with your actual DSN
  integrations: [nodeProfilingIntegration()],
  // Performance Monitoring
  tracesSampleRate: 1.0,
});

// Optional: Start profiler
Sentry.profiler.startProfiler();

// Optional: Create a test transaction
Sentry.startSpan(
  {
    name: "Application Startup",
  },
  () => {
    // Application startup logic here
  }
);

export { Sentry };

================
File: .eslintrc.json
================
{
  "extends": ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "root": true,
  "rules": {
    "@typescript-eslint/no-unused-vars": [
      "error",
      { "argsIgnorePattern": "^_", "varsIgnorePattern": "^_" }
    ],
    "@typescript-eslint/no-explicit-any": ["warn", { "ignoreRestArgs": true }]
  }
}

================
File: .gitignore
================
# Dependencies
node_modules/

# Build
dist/

# Environment
.env
.env.*

# Logs
logs/
*.log

# IDE
.vscode/
.idea/

# Misc
.DS_Store

================
File: backend-notes.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-22T15:40:13.408Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
prisma/
  migrations/
    0001_create_users_table
  schema.prisma
src/
  config/
    app.ts
    supabase.ts
    swagger.ts
  controllers/
    auth.controller.ts
    claims.controller.ts
  middleware/
    asyncHandler.ts
    auth.ts
    docs.ts
    errorHandler.ts
  routes/
    auth.ts
    claims.ts
  scripts/
    seedDatabase.ts
  types/
    api.ts
    auth.ts
  utils/
    apiResponse.ts
    errors.ts
  index.ts
  instrument.ts
.gitignore
package.json
README.md
tsconfig.json

================================================================
Repository Files
================================================================

================
File: prisma/migrations/0001_create_users_table
================
-- Create users table
CREATE TABLE public.users (
    id UUID REFERENCES auth.users(id) PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    first_name TEXT,
    last_name TEXT,
    phone TEXT,
    role TEXT NOT NULL CHECK (role IN ('USER', 'CCA', 'CCM', 'ADMIN', 'SUDO')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Enable Row Level Security (RLS)
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view their own record" ON public.users
    FOR SELECT
    USING (auth.uid() = id);

CREATE POLICY "Admins can view all records" ON public.users
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.users
            WHERE id = auth.uid() AND role IN ('ADMIN', 'SUDO')
        )
    );

-- Function to handle user updates
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for updated_at
CREATE TRIGGER set_updated_at
    BEFORE UPDATE ON public.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

================
File: prisma/schema.prisma
================
// This is your Prisma schema file
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "@prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  claims    Claim[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Claim {
  id            String         @id @default(uuid())
  claimNumber   String        @unique
  status        ClaimStatus   @default(DRAFT)
  vehicleInfo   VehicleInfo?
  parts         Part[]
  documents     Document[]
  assignedTo    User?         @relation(fields: [assignedToId], references: [id])
  assignedToId  String?
  totalAmount   Float         @default(0)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
}

model VehicleInfo {
  id          String   @id @default(uuid())
  make        String
  model       String
  year        Int
  vin         String
  claim       Claim    @relation(fields: [claimId], references: [id])
  claimId     String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Part {
  id          String    @id @default(uuid())
  partNumber  String
  description String
  quantity    Int
  unitPrice   Float
  claim       Claim     @relation(fields: [claimId], references: [id])
  claimId     String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model Document {
  id          String    @id @default(uuid())
  name        String
  type        String
  url         String
  claim       Claim     @relation(fields: [claimId], references: [id])
  claimId     String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

enum Role {
  ADMIN
  MANAGER
  USER
}

enum ClaimStatus {
  DRAFT
  SUBMITTED
  IN_REVIEW
  APPROVED
  REJECTED
  COMPLETED
}

================
File: src/config/app.ts
================
// src/config/app.ts
import dotenv from "dotenv";

dotenv.config();

export const config = {
  app: {
    name: "CMS Backend",
    port: process.env.PORT || 5001,
    env: process.env.NODE_ENV || "development",
  },
  supabase: {
    url: process.env.SUPABASE_URL,
    anonKey: process.env.SUPABASE_ANON_KEY,
    serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY,
  },
  sentry: {
    dsn: process.env.SENTRY_DSN,
  },
  database: {
    url: process.env.DATABASE_URL,
    directUrl: process.env.DIRECT_URL,
  },
};

================
File: src/config/supabase.ts
================
// src/config/supabase.ts
import { createClient } from "@supabase/supabase-js";
import { config } from "./app";

if (!config.supabase.url || !config.supabase.anonKey) {
  throw new Error("Missing Supabase configuration");
}

export const supabase = createClient(
  config.supabase.url,
  config.supabase.anonKey
);

// Define the enum first
export enum UserRole {
  USER = "USER", // Web user
  CCA = "CCA", // Call Centre Agent
  CCM = "CCM", // Call Centre Manager
  ADMIN = "ADMIN", // Administrator
  SUDO = "SUDO", // Super Admin
}

// Then use it in ROLE_HIERARCHY
export const ROLE_HIERARCHY: Record<UserRole, number> = {
  [UserRole.SUDO]: 5,
  [UserRole.ADMIN]: 4,
  [UserRole.CCM]: 3,
  [UserRole.CCA]: 2,
  [UserRole.USER]: 1,
};

// Add a type guard function to check if a string is a valid UserRole
export function isValidUserRole(role: string): role is UserRole {
  return Object.values(UserRole).includes(role as UserRole);
}

================
File: src/config/swagger.ts
================
// src/config/swagger.ts
import swaggerJsdoc from "swagger-jsdoc";

const options = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "CMS Backend API Documentation",
      version: "1.0.0",
      description: "Documentation for the Claims Management System API",
      license: {
        name: "MIT",
        url: "https://spdx.org/licenses/MIT.html",
      },
      contact: {
        name: "API Support",
        url: "https://your-support-url.com",
        email: "your-email@example.com",
      },
    },
    servers: [
      {
        url: "http://localhost:5001",
        description: "Development server",
      },
      {
        url: "https://your-production-url.com",
        description: "Production server",
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          bearerFormat: "JWT",
        },
      },
    },
  },
  apis: ["./src/routes/*.ts"], // Path to the API routes
};

export const specs = swaggerJsdoc(options);

================
File: src/controllers/auth.controller.ts
================
// src/controllers/auth.controller.ts
import { Request, Response } from "express";
import { supabase } from "../config/supabase";
import { ApiResponse } from "../utils/apiResponse";
import { AppError } from "../utils/errors";
import { AuthenticatedRequest } from "../middleware/auth";
import {
  LoginRequest,
  RegisterRequest,
  UpdateProfileRequest,
} from "../types/auth";

export class AuthController {
  static async register(req: Request, res: Response) {
    try {
      const {
        email,
        password,
        firstName,
        lastName,
        phone,
        role,
      }: RegisterRequest = req.body;

      // Register user with Supabase Auth
      const { data: authData, error: authError } = await supabase.auth.signUp({
        email,
        password,
      });

      if (authError) throw new AppError(authError.message, 400);

      // Create user profile
      const { data: profileData, error: profileError } = await supabase
        .from("users") // Changed from user_profiles to users
        .insert({
          id: authData.user!.id,
          email,
          first_name: firstName,
          last_name: lastName,
          phone,
          role: role || "USER",
          created_at: new Date(),
          updated_at: new Date(),
        })
        .single();

      if (profileError) throw new AppError(profileError.message, 400);

      return ApiResponse.success(
        res,
        profileData,
        "User registered successfully",
        201
      );
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  }

  static async login(req: Request, res: Response) {
    try {
      const { email, password }: LoginRequest = req.body;

      // Authenticate with Supabase
      const { data: authData, error: authError } =
        await supabase.auth.signInWithPassword({
          email,
          password,
        });

      if (authError) throw new AppError(authError.message, 401);

      // Fetch user profile including role
      const { data: userData, error: userError } = await supabase
        .from("users")
        .select("*")
        .eq("id", authData.user.id)
        .single();

      if (userError) throw new AppError(userError.message, 400);

      // Update last sign in
      await supabase
        .from("users")
        .update({ updated_at: new Date() })
        .eq("id", authData.user.id);

      // Combine auth data with user profile
      const responseData = {
        user: {
          ...authData.user,
          ...userData, // This will include the role
        },
        session: authData.session,
      };

      return ApiResponse.success(res, responseData, "Login successful");
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  }

  static async logout(req: AuthenticatedRequest, res: Response) {
    try {
      const { error } = await supabase.auth.signOut();

      if (error) throw new AppError(error.message, 400);

      return ApiResponse.success(res, null, "Logout successful");
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  }

  static async getProfile(req: AuthenticatedRequest, res: Response) {
    try {
      const { data: profile, error } = await supabase
        .from("users")
        .select("*")
        .eq("id", req.user.id)
        .single();

      if (error) throw new AppError(error.message, 400);

      return ApiResponse.success(
        res,
        profile,
        "Profile retrieved successfully"
      );
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  }

  static async updateProfile(req: AuthenticatedRequest, res: Response) {
    try {
      const { firstName, lastName, phone }: UpdateProfileRequest = req.body;

      const { data, error } = await supabase
        .from("users") // Changed from user_profiles to users
        .update({
          first_name: firstName,
          last_name: lastName,
          phone,
          updated_at: new Date(),
        })
        .eq("id", req.user.id)
        .single();

      if (error) throw new AppError(error.message, 400);

      return ApiResponse.success(res, data, "Profile updated successfully");
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  }
}

================
File: src/controllers/claims.controller.ts
================
import { Request, Response } from "express";
import { PrismaClient } from "@prisma/client";
import { asyncHandler } from "../middleware/asyncHandler";

const prisma = new PrismaClient();

// Get all claims with pagination
export const getClaims = asyncHandler(async (req: Request, res: Response) => {
  const page = parseInt(req.query.page as string) || 1;
  const limit = parseInt(req.query.limit as string) || 10;
  const skip = (page - 1) * limit;

  const [claims, total] = await Promise.all([
    prisma.claim.findMany({
      skip,
      take: limit,
      include: {
        vehicleInfo: true,
        assignedTo: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    }),
    prisma.claim.count(),
  ]);

  res.json({
    success: true,
    data: claims,
    pagination: {
      total,
      page,
      pages: Math.ceil(total / limit),
      limit,
    },
  });
});

// Get single claim
export const getClaim = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;

  const claim = await prisma.claim.findUnique({
    where: { id },
    include: {
      vehicleInfo: true,
      parts: true,
      documents: true,
      assignedTo: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  if (!claim) {
    return res.status(404).json({
      success: false,
      error: "Claim not found",
    });
  }

  res.json({
    success: true,
    data: claim,
  });
});

// Create new claim
export const createClaim = asyncHandler(async (req: Request, res: Response) => {
  const { vehicleInfo, ...claimData } = req.body;

  const claim = await prisma.claim.create({
    data: {
      ...claimData,
      vehicleInfo: {
        create: vehicleInfo,
      },
    },
    include: {
      vehicleInfo: true,
    },
  });

  res.status(201).json({
    success: true,
    data: claim,
  });
});

// Update claim
export const updateClaim = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;
  const { vehicleInfo, ...claimData } = req.body;

  const claim = await prisma.claim.update({
    where: { id },
    data: {
      ...claimData,
      vehicleInfo: vehicleInfo
        ? {
            update: vehicleInfo,
          }
        : undefined,
    },
    include: {
      vehicleInfo: true,
      parts: true,
      documents: true,
    },
  });

  res.json({
    success: true,
    data: claim,
  });
});

// Delete claim
export const deleteClaim = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;

  await prisma.claim.delete({
    where: { id },
  });

  res.json({
    success: true,
    data: {},
  });
});

// Add part to claim
export const addPartToClaim = asyncHandler(
  async (req: Request, res: Response) => {
    const { id } = req.params;
    const partData = req.body;

    const part = await prisma.part.create({
      data: {
        ...partData,
        claim: {
          connect: { id },
        },
      },
    });

    // Update claim total amount
    await prisma.claim.update({
      where: { id },
      data: {
        totalAmount: {
          increment: partData.quantity * partData.unitPrice,
        },
      },
    });

    res.status(201).json({
      success: true,
      data: part,
    });
  }
);

// Upload document
export const uploadDocument = asyncHandler(
  async (req: Request, res: Response) => {
    const { id } = req.params;
    const { name, type, url } = req.body;

    const document = await prisma.document.create({
      data: {
        name,
        type,
        url,
        claim: {
          connect: { id },
        },
      },
    });

    res.status(201).json({
      success: true,
      data: document,
    });
  }
);

================
File: src/middleware/asyncHandler.ts
================
import { Request, Response, NextFunction, RequestHandler } from "express";

type AsyncRequestHandler = (
  req: Request,
  res: Response,
  next: NextFunction
) => Promise<any>;

export const asyncHandler =
  (fn: AsyncRequestHandler): RequestHandler =>
  (req: Request, res: Response, next: NextFunction): void => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };

================
File: src/middleware/auth.ts
================
// src/middleware/auth.ts
import { Request, Response, NextFunction } from "express";
import { supabase, UserRole, ROLE_HIERARCHY } from "../config/supabase";
import { AppError } from "../utils/errors";
import { ApiResponse } from "../utils/apiResponse";

export interface AuthenticatedRequest extends Request {
  user?: any;
}

export const authenticate = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];

    if (!token) {
      throw new AppError("No authentication token provided", 401);
    }

    const {
      data: { user },
      error,
    } = await supabase.auth.getUser(token);

    if (error || !user) {
      throw new AppError("Invalid or expired token", 401);
    }

    // Get user's role from user_profiles table
    const { data: profile, error: profileError } = await supabase
      .from("user_profiles")
      .select("*")
      .eq("id", user.id)
      .single();

    if (profileError || !profile) {
      throw new AppError("User profile not found", 404);
    }

    req.user = { ...user, ...profile };
    next();
  } catch (error) {
    return ApiResponse.error(res, error.message, error.statusCode || 500);
  }
};

export const authorize = (...allowedRoles: UserRole[]) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      if (!req.user || !req.user.role) {
        throw new AppError("User not authenticated", 401);
      }

      const userRoleLevel = ROLE_HIERARCHY[req.user.role];
      const hasPermission = allowedRoles.some(
        (role) => ROLE_HIERARCHY[role] <= userRoleLevel
      );

      if (!hasPermission) {
        throw new AppError("Insufficient permissions", 403);
      }

      next();
    } catch (error) {
      return ApiResponse.error(res, error.message, error.statusCode || 500);
    }
  };
};

================
File: src/middleware/docs.ts
================
// src/middleware/docs.ts
import { Express, Request, Response } from "express";
import swaggerUi from "swagger-ui-express";
import { specs } from "../config/swagger";

export const setupDocs = (app: Express) => {
  // Swagger documentation route
  app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(specs));

  // JSON version of documentation
  app.get("/api-docs.json", (req: Request, res: Response) => {
    res.setHeader("Content-Type", "application/json");
    res.send(specs);
  });
};

================
File: src/middleware/errorHandler.ts
================
// src/middleware/errorHandler.ts
import { Request, Response, NextFunction } from "express";
import * as Sentry from "@sentry/node";
import { config } from "../config/app";
import { AppError } from "../utils/errors";

export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Log error
  console.error(error);

  // Capture error in Sentry
  Sentry.captureException(error);

  // Check if error is operational
  if (error instanceof AppError) {
    return res.status(error.statusCode).json({
      status: error.status,
      message: error.message,
      ...(config.app.env === "development" && { stack: error.stack }),
    });
  }

  // Handle unexpected errors
  return res.status(500).json({
    status: "error",
    message: "Something went wrong!",
    ...(config.app.env === "development" && { stack: error.stack }),
    ...(res.sentry ? { sentryEventId: res.sentry } : {}),
  });
};

================
File: src/routes/auth.ts
================
// src/routes/auth.ts
import { Router } from "express";
import { AuthController } from "../controllers/auth.controller";
import { authenticate, authorize } from "../middleware/auth";
import { UserRole } from "../config/supabase";
import { asyncHandler } from "../middleware/asyncHandler";

const router = Router();

/**
 * @swagger
 * /auth/register:
 *   post:
 *     summary: Register a new user
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - firstName
 *               - lastName
 *             properties:
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               phone:
 *                 type: string
 *               role:
 *                 type: string
 *                 enum: [USER, CCA, CCM, ADMIN, SUDO]
 */
router.post(
  "/register",
  authenticate,
  authorize(UserRole.ADMIN, UserRole.SUDO),
  asyncHandler(AuthController.register)
);

/**
 * @swagger
 * /auth/login:
 *   post:
 *     summary: Login to the application
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 */
router.post("/login", asyncHandler(AuthController.login));

/**
 * @swagger
 * /auth/logout:
 *   post:
 *     summary: Logout from the application
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 */
router.post("/logout", authenticate, asyncHandler(AuthController.logout));

/**
 * @swagger
 * /auth/profile:
 *   get:
 *     summary: Get user profile
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 */
router.get("/profile", authenticate, asyncHandler(AuthController.getProfile));

/**
 * @swagger
 * /auth/profile:
 *   put:
 *     summary: Update user profile
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               phone:
 *                 type: string
 */
router.put(
  "/profile",
  authenticate,
  asyncHandler(AuthController.updateProfile)
);

export default router;

================
File: src/routes/claims.ts
================
import express from "express";
import {
  getClaims,
  getClaim,
  createClaim,
  updateClaim,
  deleteClaim,
  addPartToClaim,
  uploadDocument,
} from "../controllers/claims.controller";
import { authenticate } from "../middleware/auth";
import { asyncHandler } from "../middleware/asyncHandler";

const router = express.Router();

/**
 * @swagger
 * /api/claims:
 *   get:
 *     summary: Get all claims with pagination
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *         description: Page number
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of claims
 */
router.get("/", authenticate, asyncHandler(getClaims));

/**
 * @swagger
 * /api/claims/{id}:
 *   get:
 *     summary: Get a single claim by ID
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Claim details
 *       404:
 *         description: Claim not found
 */
router.get("/:id", authenticate, asyncHandler(getClaim));

/**
 * @swagger
 * /api/claims:
 *   post:
 *     summary: Create a new claim
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - claimNumber
 *               - vehicleInfo
 *             properties:
 *               claimNumber:
 *                 type: string
 *               vehicleInfo:
 *                 type: object
 *     responses:
 *       201:
 *         description: Claim created successfully
 */
router.post("/", authenticate, asyncHandler(createClaim));

/**
 * @swagger
 * /api/claims/{id}:
 *   put:
 *     summary: Update a claim
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *     responses:
 *       200:
 *         description: Claim updated successfully
 *       404:
 *         description: Claim not found
 */
router.put("/:id", authenticate, asyncHandler(updateClaim));

/**
 * @swagger
 * /api/claims/{id}:
 *   delete:
 *     summary: Delete a claim
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Claim deleted successfully
 *       404:
 *         description: Claim not found
 */
router.delete("/:id", authenticate, asyncHandler(deleteClaim));

/**
 * @swagger
 * /api/claims/{id}/parts:
 *   post:
 *     summary: Add a part to a claim
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - partNumber
 *               - description
 *               - quantity
 *               - unitPrice
 *             properties:
 *               partNumber:
 *                 type: string
 *               description:
 *                 type: string
 *               quantity:
 *                 type: number
 *               unitPrice:
 *                 type: number
 *     responses:
 *       201:
 *         description: Part added successfully
 */
router.post("/:id/parts", authenticate, asyncHandler(addPartToClaim));

/**
 * @swagger
 * /api/claims/{id}/documents:
 *   post:
 *     summary: Upload a document to a claim
 *     tags: [Claims]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - type
 *               - url
 *             properties:
 *               name:
 *                 type: string
 *               type:
 *                 type: string
 *               url:
 *                 type: string
 *     responses:
 *       201:
 *         description: Document uploaded successfully
 */
router.post("/:id/documents", authenticate, asyncHandler(uploadDocument));

export default router;

================
File: src/scripts/seedDatabase.ts
================
// src/scripts/seedDatabase.ts
import { supabase } from "../config/supabase";
import { UserRole } from "../config/supabase";

async function seedDatabase() {
  try {
    // Check if SUDO user exists
    const {
      data,
      count,
      error: countError,
    } = await supabase
      .from("users")
      .select("*", { count: "exact" })
      .eq("role", UserRole.SUDO)
      .limit(1);

    if (countError) {
      throw countError;
    }

    if (count && count > 0) {
      console.log("SUDO user already exists");
      return;
    }

    // Create SUDO user
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email: process.env.SUDO_EMAIL || "sudo@example.com",
      password: process.env.SUDO_PASSWORD || "StrongPassword123!",
      options: {
        data: {
          first_name: "Super",
          last_name: "Admin",
          role: UserRole.SUDO,
        },
      },
    });

    if (authError) {
      throw authError;
    }

    if (!authData.user) {
      throw new Error("No user data returned from auth signup");
    }

    // Create user record
    const { error: userError } = await supabase.from("users").insert([
      {
        id: authData.user.id,
        email: process.env.SUDO_EMAIL || "sudo@example.com",
        first_name: "Super",
        last_name: "Admin",
        role: UserRole.SUDO,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
    ]);

    if (userError) {
      throw userError;
    }

    console.log(" SUDO user created successfully");
  } catch (error) {
    console.error(" Error seeding database:", error);
    process.exit(1);
  }
}

// Run the seeding
seedDatabase().catch((error) => {
  console.error("Fatal error during database seeding:", error);
  process.exit(1);
});

================
File: src/types/api.ts
================
// src/types/api.ts
export interface ErrorResponse {
  error: string;
  details?: any;
}

export interface SuccessResponse<T> {
  data: T;
  message?: string;
}

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
}

================
File: src/types/auth.ts
================
// src/types/auth.ts

export enum UserRole {
  USER = "USER", // Web user
  CCA = "CCA", // Call Centre Agent
  CCM = "CCM", // Call Centre Manager
  ADMIN = "ADMIN", // Administrator
  SUDO = "SUDO", // Super Admin
}

export const ROLE_HIERARCHY = {
  [UserRole.SUDO]: 5,
  [UserRole.ADMIN]: 4,
  [UserRole.CCM]: 3,
  [UserRole.CCA]: 2,
  [UserRole.USER]: 1,
};

// Role permissions interface
export interface RolePermissions {
  canViewDashboard: boolean;
  canHandleCalls: boolean;
  canManageAgents: boolean;
  canViewReports: boolean;
  canManageUsers: boolean;
  canManageSystem: boolean;
}

// Default permissions for each role
export const ROLE_PERMISSIONS: Record<UserRole, RolePermissions> = {
  [UserRole.SUDO]: {
    canViewDashboard: true,
    canHandleCalls: true,
    canManageAgents: true,
    canViewReports: true,
    canManageUsers: true,
    canManageSystem: true,
  },
  [UserRole.ADMIN]: {
    canViewDashboard: true,
    canHandleCalls: true,
    canManageAgents: true,
    canViewReports: true,
    canManageUsers: true,
    canManageSystem: false,
  },
  [UserRole.CCM]: {
    canViewDashboard: true,
    canHandleCalls: true,
    canManageAgents: true,
    canViewReports: true,
    canManageUsers: false,
    canManageSystem: false,
  },
  [UserRole.CCA]: {
    canViewDashboard: true,
    canHandleCalls: true,
    canManageAgents: false,
    canViewReports: false,
    canManageUsers: false,
    canManageSystem: false,
  },
  [UserRole.USER]: {
    canViewDashboard: false,
    canHandleCalls: false,
    canManageAgents: false,
    canViewReports: false,
    canManageUsers: false,
    canManageSystem: false,
  },
};

// User interface
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: UserRole;
  phone?: string;
  createdAt?: Date;
  updatedAt?: Date;
}

// Helper functions
export function hasPermission(
  role: UserRole,
  permission: keyof RolePermissions
): boolean {
  return ROLE_PERMISSIONS[role][permission];
}

export function isRoleHigherThan(role1: UserRole, role2: UserRole): boolean {
  return ROLE_HIERARCHY[role1] > ROLE_HIERARCHY[role2];
}

// Auth response types
export interface AuthResponse {
  user: User | null;
  session: any | null;
  error?: string;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterData extends LoginCredentials {
  firstName: string;
  lastName: string;
  phone?: string;
  role?: UserRole;
}

================
File: src/utils/apiResponse.ts
================
// src/utils/apiResponse.ts
import { Response } from "express";
import {
  SuccessResponse,
  ErrorResponse,
  PaginatedResponse,
} from "../types/api";

export class ApiResponse {
  static success<T>(
    res: Response,
    data: T,
    message?: string,
    statusCode = 200
  ): Response {
    const response: SuccessResponse<T> = {
      data,
      message,
    };
    return res.status(statusCode).json(response);
  }

  static error(
    res: Response,
    error: string,
    statusCode = 500,
    details?: any
  ): Response {
    const response: ErrorResponse = {
      error,
      details,
    };
    return res.status(statusCode).json(response);
  }

  static paginated<T>(
    res: Response,
    data: T[],
    total: number,
    page: number,
    limit: number
  ): Response {
    const response: PaginatedResponse<T> = {
      data,
      total,
      page,
      limit,
    };
    return res.status(200).json(response);
  }
}

================
File: src/utils/asyncHandler.ts
================
import { Request, Response, NextFunction, RequestHandler } from "express";

type AsyncRequestHandler = (
  req: Request,
  res: Response,
  next: NextFunction
) => Promise<void | Response>;

export const asyncHandler = (fn: AsyncRequestHandler): RequestHandler => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

================
File: src/utils/errors.ts
================
// src/utils/errors.ts
export class AppError extends Error {
  statusCode: number;
  status: string;
  isOperational: boolean;

  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith("4") ? "fail" : "error";
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

================
File: src/index.ts
================
// src/index.ts
import "./instrument"; // Must be first import
import * as Sentry from "@sentry/node";
import express from "express";
import cors from "cors";
import helmet from "helmet";
import { config } from "./config/app";
import { setupDocs } from "./middleware/docs";
import authRoutes from "./routes/auth";

const app = express();

// Basic middleware
app.use(cors());
app.use(helmet());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Setup API documentation
setupDocs(app);

// Routes
app.use("/auth", authRoutes);

// Basic health check route
app.get("/health", (req, res) => {
  res.json({
    status: "ok",
    timestamp: new Date(),
    environment: config.app.env,
  });
});

// Test Sentry
app.get("/debug-sentry", function mainHandler(req, res) {
  throw new Error("My first Sentry error!");
});

// The error handler must be registered before any other error middleware and after all controllers
Sentry.setupExpressErrorHandler(app);

// Optional fallthrough error handler
app.use(function onError(
  err: Error,
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  // The error id is attached to res.sentry to be returned
  res.statusCode = 500;
  res.end(res.sentry + "\n");
});

// Start server
const server = app.listen(config.app.port, () => {
  console.log(
    ` Server running on port ${config.app.port} in ${config.app.env} mode`
  );
});

export default server;

================
File: src/instrument.ts
================
import { dotenv } from "dotenv";
// src/instrument.ts
import * as Sentry from "@sentry/node";
import { nodeProfilingIntegration } from "@sentry/profiling-node";

Sentry.init({
  dsn: process.env.SENTRY_DSN, // Replace with your actual DSN
  integrations: [nodeProfilingIntegration()],
  // Performance Monitoring
  tracesSampleRate: 1.0,
});

// Optional: Start profiler
Sentry.profiler.startProfiler();

// Optional: Create a test transaction
Sentry.startSpan(
  {
    name: "Application Startup",
  },
  () => {
    // Application startup logic here
  }
);

export { Sentry };

================
File: .gitignore
================
# Dependencies
node_modules/

# Build
dist/

# Environment
.env
.env.*

# Logs
logs/
*.log

# IDE
.vscode/
.idea/

# Misc
.DS_Store

================
File: package.json
================
{
  "name": "cms-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate deploy",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write \"src/**/*.ts\"",
    "seed": "ts-node src/scripts/seedDatabase.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@prisma/client": "^6.1.0",
    "@sentry/node": "^8.47.0",
    "@sentry/profiling-node": "^8.47.0",
    "@sentry/tracing": "^7.114.0",
    "@supabase/supabase-js": "^2.47.10",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-rate-limit": "^7.5.0",
    "helmet": "^8.0.0",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.0",
    "@types/node": "^22.10.2",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.7",
    "@typescript-eslint/eslint-plugin": "^8.18.1",
    "@typescript-eslint/parser": "^8.18.1",
    "prettier": "^3.4.2",
    "prisma": "^6.1.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.7.2"
  }
}

================
File: README.md
================
# CMS Backend

Backend service for the Claims Management System built with Express.js, Prisma, and Supabase.

## Project Structure

## Setup

## Prerequisites

Before you begin, ensure you have:

- Node.js 18.x or higher installed
- A Supabase project created
- A Sentry account for error tracking
- Access to environment variables

## Setup Instructions

1. **Clone the repository**

   ```bash
   git clone <repository-url>
   cd cms-backend

   ```

2.

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2017",
    "module": "commonjs",
    "lib": ["es2017", "esnext.asynciterable"],
    "typeRoots": ["./node_modules/@types", "./src/types"],
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "esModuleInterop": true,
    "strict": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
